#!/usr/bin/env python3
"""
Vulnerability Reporter Module
-----------------------------
GRC Automation Toolkit - Module 04

Processes vulnerability scan results (JSON format) and generates
executive-ready reports with:
- CVSS-based severity categorization
- Remediation priority scoring
- Asset grouping and statistics
- Trend analysis support

Compatible with common scanner outputs (Nessus, OpenVAS-style JSON).

Author: osayande-infosec
License: MIT
"""

from __future__ import annotations

import argparse
import json
from collections import Counter, defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional


@dataclass
class Vulnerability:
    """Represents a single vulnerability finding."""
    vuln_id: str
    title: str
    severity: str  # critical, high, medium, low, info
    cvss_score: float
    cve_ids: List[str]
    affected_asset: str
    description: str
    solution: str
    plugin_id: str = ""
    port: str = ""
    protocol: str = ""
    first_seen: Optional[datetime] = None
    last_seen: Optional[datetime] = None


@dataclass
class VulnReport:
    """Vulnerability analysis report."""
    total_findings: int
    unique_vulns: int
    affected_assets: int
    by_severity: Dict[str, int]
    by_asset: Dict[str, int]
    critical_vulns: List[Vulnerability]
    high_vulns: List[Vulnerability]
    top_cves: List[tuple]
    remediation_priority: List[Vulnerability]
    risk_score: float  # Calculated overall risk


def parse_severity(severity_str: str, cvss: float = 0.0) -> str:
    """Normalize severity string."""
    severity = severity_str.lower().strip()
    
    # Map common variations
    if severity in ("critical", "4", "crit"):
        return "critical"
    elif severity in ("high", "3"):
        return "high"
    elif severity in ("medium", "moderate", "2", "med"):
        return "medium"
    elif severity in ("low", "1"):
        return "low"
    elif severity in ("info", "informational", "0", "none"):
        return "info"
    
    # Fallback to CVSS-based
    if cvss >= 9.0:
        return "critical"
    elif cvss >= 7.0:
        return "high"
    elif cvss >= 4.0:
        return "medium"
    elif cvss > 0:
        return "low"
    return "info"


def parse_datetime(dt_str: str) -> Optional[datetime]:
    """Parse datetime string."""
    if not dt_str:
        return None
    
    formats = [
        "%Y-%m-%dT%H:%M:%S",
        "%Y-%m-%dT%H:%M:%SZ",
        "%Y-%m-%d %H:%M:%S",
        "%Y-%m-%d",
    ]
    for fmt in formats:
        try:
            return datetime.strptime(dt_str.strip(), fmt)
        except ValueError:
            continue
    return None


def load_vulnerabilities(json_path: Path) -> List[Vulnerability]:
    """Load vulnerabilities from JSON file."""
    with json_path.open(encoding="utf-8") as f:
        data = json.load(f)
    
    vulns = []
    
    # Handle different JSON structures
    findings = data if isinstance(data, list) else data.get("findings", data.get("vulnerabilities", data.get("results", [])))
    
    for item in findings:
        # Normalize field names (support multiple scanner formats)
        cvss = float(item.get("cvss_score", item.get("cvss", item.get("risk_score", 0))) or 0)
        severity_raw = item.get("severity", item.get("risk", item.get("threat", "")))
        
        cve_ids = item.get("cve_ids", item.get("cves", []))
        if isinstance(cve_ids, str):
            cve_ids = [cve_ids] if cve_ids else []
        
        vuln = Vulnerability(
            vuln_id=str(item.get("id", item.get("vuln_id", item.get("plugin_id", "")))),
            title=item.get("title", item.get("name", item.get("vulnerability", "Unknown"))),
            severity=parse_severity(severity_raw, cvss),
            cvss_score=cvss,
            cve_ids=cve_ids,
            affected_asset=item.get("asset", item.get("host", item.get("target", "Unknown"))),
            description=item.get("description", item.get("synopsis", ""))[:500],
            solution=item.get("solution", item.get("remediation", item.get("fix", ""))),
            plugin_id=str(item.get("plugin_id", "")),
            port=str(item.get("port", "")),
            protocol=item.get("protocol", ""),
            first_seen=parse_datetime(item.get("first_seen", "")),
            last_seen=parse_datetime(item.get("last_seen", "")),
        )
        vulns.append(vuln)
    
    return vulns


def calculate_risk_score(vulns: List[Vulnerability]) -> float:
    """Calculate overall risk score (0-100)."""
    if not vulns:
        return 0.0
    
    # Weight by severity
    severity_weights = {
        "critical": 40,
        "high": 20,
        "medium": 5,
        "low": 1,
        "info": 0,
    }
    
    total_weight = sum(severity_weights.get(v.severity, 0) for v in vulns)
    
    # Normalize to 0-100 scale (cap at 100)
    max_expected = len(vulns) * 10  # Assume average "high" severity
    score = min(100, (total_weight / max_expected) * 100) if max_expected > 0 else 0
    
    return round(score, 1)


def prioritize_remediation(vulns: List[Vulnerability]) -> List[Vulnerability]:
    """Prioritize vulnerabilities for remediation."""
    # Score based on severity and presence of CVE
    def priority_score(v: Vulnerability) -> tuple:
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
        has_cve = 0 if v.cve_ids else 1
        return (severity_order.get(v.severity, 5), has_cve, -v.cvss_score)
    
    return sorted(vulns, key=priority_score)


def analyze_vulnerabilities(vulns: List[Vulnerability]) -> VulnReport:
    """Analyze vulnerabilities and generate report."""
    by_severity = Counter(v.severity for v in vulns)
    by_asset = Counter(v.affected_asset for v in vulns)
    
    # Unique vulnerabilities (by title)
    unique_titles = set(v.title for v in vulns)
    
    # Get critical and high vulns
    critical = [v for v in vulns if v.severity == "critical"]
    high = [v for v in vulns if v.severity == "high"]
    
    # Top CVEs
    all_cves = []
    for v in vulns:
        all_cves.extend(v.cve_ids)
    top_cves = Counter(all_cves).most_common(10)
    
    # Prioritized remediation list
    remediation_priority = prioritize_remediation(vulns)
    
    return VulnReport(
        total_findings=len(vulns),
        unique_vulns=len(unique_titles),
        affected_assets=len(by_asset),
        by_severity=dict(by_severity),
        by_asset=dict(by_asset),
        critical_vulns=critical,
        high_vulns=high,
        top_cves=top_cves,
        remediation_priority=remediation_priority[:20],
        risk_score=calculate_risk_score(vulns),
    )


def print_report(report: VulnReport, verbose: bool = False) -> None:
    """Print formatted vulnerability report."""
    print("\n" + "=" * 60)
    print("VULNERABILITY ASSESSMENT REPORT")
    print("=" * 60)
    
    # Risk score banner
    risk_color = "ðŸ”´" if report.risk_score >= 70 else "ðŸŸ " if report.risk_score >= 40 else "ðŸŸ¢"
    print(f"\n{risk_color} OVERALL RISK SCORE: {report.risk_score}/100")
    
    print(f"\nðŸ“Š SUMMARY")
    print(f"   Total Findings: {report.total_findings}")
    print(f"   Unique Vulnerabilities: {report.unique_vulns}")
    print(f"   Affected Assets: {report.affected_assets}")
    
    print(f"\nðŸŽ¯ BY SEVERITY")
    severity_order = ["critical", "high", "medium", "low", "info"]
    severity_icons = {"critical": "ðŸ”´", "high": "ðŸŸ ", "medium": "ðŸŸ¡", "low": "ðŸ”µ", "info": "âšª"}
    for sev in severity_order:
        count = report.by_severity.get(sev, 0)
        if count > 0:
            print(f"   {severity_icons[sev]} {sev.capitalize()}: {count}")
    
    # Critical findings (always show)
    if report.critical_vulns:
        print(f"\nðŸš¨ CRITICAL FINDINGS ({len(report.critical_vulns)})")
        for v in report.critical_vulns[:5]:
            cves = ", ".join(v.cve_ids[:3]) if v.cve_ids else "No CVE"
            print(f"   â€¢ {v.title}")
            print(f"     Asset: {v.affected_asset} | CVSS: {v.cvss_score} | {cves}")
    
    if report.top_cves:
        print(f"\nðŸ“‹ TOP CVEs FOUND")
        for cve, count in report.top_cves[:5]:
            print(f"   â€¢ {cve}: {count} occurrence(s)")
    
    if verbose:
        print(f"\nðŸ“Œ REMEDIATION PRIORITY (Top 10)")
        for i, v in enumerate(report.remediation_priority[:10], 1):
            print(f"   {i}. [{v.severity.upper()}] {v.title}")
            if v.solution:
                print(f"      Fix: {v.solution[:80]}...")
        
        print(f"\nðŸ–¥ï¸  ASSETS BY FINDING COUNT")
        sorted_assets = sorted(report.by_asset.items(), key=lambda x: -x[1])
        for asset, count in sorted_assets[:10]:
            print(f"   â€¢ {asset}: {count}")
    
    print("\n" + "=" * 60 + "\n")


def export_csv(report: VulnReport, output_path: Path) -> None:
    """Export prioritized findings to CSV."""
    import csv
    
    with output_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Priority", "Severity", "Title", "Asset", "CVSS", "CVEs", "Solution"])
        
        for i, v in enumerate(report.remediation_priority, 1):
            writer.writerow([
                i,
                v.severity,
                v.title,
                v.affected_asset,
                v.cvss_score,
                "; ".join(v.cve_ids),
                v.solution[:200],
            ])
    
    print(f"Exported to {output_path}")


def main() -> None:
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Generate vulnerability reports from scan results.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python vuln_reporter.py --json scan_results.json
  python vuln_reporter.py --json findings.json --verbose --export report.csv
        """
    )
    parser.add_argument(
        "--json", "-j",
        required=True,
        type=Path,
        help="Path to JSON vulnerability file"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show detailed output"
    )
    parser.add_argument(
        "--export", "-e",
        type=Path,
        help="Export prioritized findings to CSV"
    )
    
    args = parser.parse_args()
    
    if not args.json.exists():
        raise SystemExit(f"File not found: {args.json}")
    
    vulns = load_vulnerabilities(args.json)
    
    if not vulns:
        raise SystemExit("No vulnerabilities found in file.")
    
    report = analyze_vulnerabilities(vulns)
    print_report(report, verbose=args.verbose)
    
    if args.export:
        export_csv(report, args.export)


if __name__ == "__main__":
    main()
